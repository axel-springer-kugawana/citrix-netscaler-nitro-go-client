package nitro

import (
        "fmt"
        "strconv"
        "strings"
)

type {{$.Name|name}} struct {
        {{range $field, $type := $.Schema.Fields -}}
        {{if eq $type "double" -}}
        {{$field|title}} {{$type|go_type}} `json:"{{$field}},string,omitempty"`
        {{else -}}
        {{$field|title}} {{$type|go_type}} `json:"{{$field}},omitempty"`
        {{end -}}
        {{end -}}
}

type {{$.Name|name}}Key struct {
        {{range $field := $.Schema.Key -}}
        {{$field|title}} {{(index $.Schema.Fields $field)|go_type}}
        {{end -}}
}

type add_{{$.Name}}_payload struct {
        Resources {{$.Name|name}} `json:"{{$.Name}}"`
}

type get_{{$.Name}}_result struct {
        Results []{{$.Name|name}} `json:"{{$.Name}}"`
}

type count_{{$.Name}}_result struct {
        Results []Count `json:"{{$.Name}}"`
}

func {{$.Name}}_key_to_id_args (key {{$.Name|name}}Key) (string, map[string]string) {
        var _ = strconv.Itoa
        var args []string

        {{range $field := $.Schema.Key -}}
        {{if eq (index $.Schema.Fields $field) "int" -}}
        args = append(args, "{{$field}}:" + strconv.Itoa(key.{{$field|title}}))
        {{else -}}
        args = append(args, "{{$field}}:" + key.{{$field|title}})
        {{end -}}
        {{end}}

        qs := map[string]string{}

        if len(args) > 0 {
                qs["args"] = strings.Join(args, ",")
        }

        return "", qs
}

func (c *NitroClient) Add{{$.Name|name}} (binding {{$.Name|name}}) error {
        payload := add_{{$.Name}}_payload {
                binding,
        }

        return c.put("{{$.Name}}", "", nil, payload)
}

func (c *NitroClient) BulkCount{{$.Name|name}} () (int, error) {
        var results count_{{$.Name}}_result
        
        qs := map[string]string {
                "bulkbindings": "yes",
                "count": "yes",
        }

	if err := c.get("{{$.Name}}", "", qs, &results); err != nil {
                return -1, err
        } else {
                return results.Results[0].Count, err
        }
}

func (c *NitroClient) Count{{$.Name|name}} (id string) (int, error) {
        var results count_{{$.Name}}_result
        
        qs := map[string]string {
                "count": "yes",
        }

	if err := c.get("{{$.Name}}", id, qs, &results); err != nil {
                return -1, err
        } else {
                return results.Results[0].Count, err
        }
}

func (c *NitroClient) Exists{{$.Name|name}} (id string) (bool, error) {
        if count, err := c.Count{{$.Name|name}}(id); err != nil {
                return false, err
        } else {
                return count == 1, nil
        }
}

func (c *NitroClient) BulkList{{$.Name|name}} () ([]{{$.Name|name}}, error) {
        var results get_{{$.Name}}_result
        
        qs := map[string]string {
                "bulkbindings": "yes",
        }

	if err := c.get("{{$.Name}}", "", qs, &results); err != nil {
                return nil, err
        } else {
                return results.Results, err
        }
}

func (c *NitroClient) List{{$.Name|name}} (id string) ([]{{$.Name|name}}, error) {
        var results get_{{$.Name}}_result

	if err := c.get("{{$.Name}}", id, nil, &results); err != nil {
                return nil, err
        } else {
                return results.Results, err
        }
}

func (c *NitroClient) Get{{$.Name|name}} (key {{$.Name|name}}Key) (*{{$.Name|name}}, error) {
        var results get_{{$.Name}}_result
        
        id, qs := {{$.Name}}_key_to_id_args(key)

	if err := c.get("{{$.Name}}", id, qs, &results); err != nil {
                return nil, err
        } else {
                if len(results.Results) > 1 {
                        return nil, fmt.Errorf("More than one {{$.Name}} element found")
                } else if len(results.Results) < 1 {
                        // TODO
                        // return nil, fmt.Errorf("{{$.Name}} element not found")
                        return nil, nil
                }

                return &results.Results[0], nil
        }
}

func (c *NitroClient) Delete{{$.Name|name}} (key {{$.Name|name}}Key) error {
        id, qs := {{$.Name}}_key_to_id_args(key)

        return c.delete("{{$.Name}}", id, qs)
}
