package nitro

import (
        "fmt"
        "strconv"
        "strings"
)

type {{$.Name|name}} struct {
        {{$.Schema.Key.Name|title}} string `json:"{{$.Schema.Key.Name}}"`
        {{if $.Schema.State -}}
        {{$.Schema.State|title}} string `json:"{{$.Schema.State}},omitempty"`
        {{end -}}
        {{range $field, $type := $.Schema.Fields -}}
        {{if eq $type "double" -}}
        {{$field|title}} {{$type|go_type}} `json:"{{$field}},string,omitempty"`
        {{else -}}
        {{$field|title}} {{$type|go_type}} `json:"{{$field}},omitempty"`
        {{end -}}
        {{end -}}
}

{{if $.Schema.Key.Fields -}}
type {{$.Name|name}}Key struct {
        {{$.Schema.Key.Name|title}} string `json:"{{$.Schema.Key.Name}}"`
        {{range $field := $.Schema.Key.Fields -}}
        {{if eq (index $.Schema.Fields $field) "double" -}}
        {{$field|title}} {{(index $.Schema.Fields $field)|go_type}} `json:"{{$field}},string,omitempty"`
        {{else -}}
        {{$field|title}} {{(index $.Schema.Fields $field)|go_type}} `json:"{{$field}},omitempty"`
        {{end -}}
        {{end -}}
}

func {{$.Name}}_key_to_id_args (key {{if $.Schema.Key.Fields}}{{$.Name|name}}Key{{else}}string{{end}}) (string, map[string]string) {
        var _ = strconv.Itoa
        var args []string

        {{range $field := $.Schema.Key.Fields -}}
        {{if eq (index $.Schema.Fields $field) "int" -}}
        args = append(args, "{{$field}}:" + strconv.Itoa(key.{{$field|title}}))
        {{else -}}
        args = append(args, "{{$field}}:" + key.{{$field|title}})
        {{end -}}
        {{end}}

        qs := map[string]string{}

        if len(args) > 0 {
                qs["args"] = strings.Join(args, ",")
        }

        return key.{{$.Schema.Key.Name|title}}, qs
}

{{else -}}
func {{$.Name}}_key_to_id_args (key {{if $.Schema.Key.Fields}}{{$.Name|name}}Key{{else}}string{{end}}) (string, map[string]string) {
        var _ = strconv.Itoa
        var _ = strings.Join

        qs := map[string]string{}

        return key, qs
}

{{end -}}
{{if $.Schema.Update -}}
type {{$.Name|name}}Unset struct {
        {{$.Schema.Key.Name|title}} string `json:"{{$.Schema.Key.Name}}"`
        {{range $field := $.Schema.Key.Fields -}}
        {{if eq (index $.Schema.Fields $field) "double" -}}
        {{$field|title}} {{(index $.Schema.Fields $field)|go_type}} `json:"{{$field}},string,omitempty"`
        {{else -}}
        {{$field|title}} {{(index $.Schema.Fields $field)|go_type}} `json:"{{$field}},omitempty"`
        {{end -}}
        {{end -}}
        {{range $field := $.Schema.Update -}}
        {{if not (is_in $field $.Schema.Key.Fields) -}}
        {{$field|title}} bool `json:"{{$field}},omitempty"`
        {{end -}}
        {{end -}}
}

type update_{{$.Name}} struct {
        {{$.Schema.Key.Name|title}} string `json:"{{$.Schema.Key.Name}}"`
        {{range $field := $.Schema.Key.Fields -}}
        {{if eq (index $.Schema.Fields $field) "double" -}}
        {{$field|title}} {{(index $.Schema.Fields $field)|go_type}} `json:"{{$field}},string,omitempty"`
        {{else -}}
        {{$field|title}} {{(index $.Schema.Fields $field)|go_type}} `json:"{{$field}},omitempty"`
        {{end -}}
        {{end -}}
        {{range $field := $.Schema.Update -}}
        {{if not (is_in $field $.Schema.Key.Fields) -}}
        {{if eq (index $.Schema.Fields $field) "double" -}}
        {{$field|title}} {{(index $.Schema.Fields $field)|go_type}} `json:"{{$field}},string,omitempty"`
        {{else -}}
        {{$field|title}} {{(index $.Schema.Fields $field)|go_type}} `json:"{{$field}},omitempty"`
        {{end -}}
        {{end -}}
        {{end -}}
}

{{end -}}
type rename_{{$.Name}} struct {
        Name string `json:"{{$.Schema.Key.Name}}"`
        Newname string `json:"newname"`
}

type add_{{$.Name}}_payload struct {
        Resource {{$.Name|name}} `json:"{{$.Name}}"`
}

type rename_{{$.Name}}_payload struct {
        Rename rename_{{$.Name}} `json:"{{$.Name}}"`
}

{{if $.Schema.State -}}
type state_{{$.Name}} struct {
        {{if $.Schema.Key.Fields -}}
        Key {{$.Name|name}}Key `json:"{{$.Schema.Key.Name}}"`
        {{else -}}
        Key string `json:"{{$.Schema.Key.Name}}"`
        {{end -}}
}

type state_{{$.Name}}_payload struct {
        Sate state_{{$.Name}} `json:"{{$.Name}}"`
}

{{end -}}
{{if $.Schema.Update -}}
type unset_{{$.Name}}_payload struct {
        Unset {{$.Name|name}}Unset `json:"{{$.Name}}"`
}

type update_{{$.Name}}_payload struct {
        Update update_{{$.Name}} `json:"{{$.Name}}"`
}

{{end -}}
type get_{{$.Name}}_result struct {
        Results []{{$.Name|name}} `json:"{{$.Name}}"`
}

type count_{{$.Name}}_result struct {
        Results []Count `json:"{{$.Name}}"`
}

func (c *NitroClient) Add{{$.Name|name}} (resource {{$.Name|name}}) error {
        payload := add_{{$.Name}}_payload {
                resource,
        }

        return c.post("{{$.Name}}", "", nil, payload)
}

func (c *NitroClient) Rename{{$.Name|name}} (name string, newName string) error {
        payload := rename_{{$.Name}}_payload {
                rename_{{$.Name}} {
                        name,
                        newName,
                },
        }

        qs := map[string]string {
                "action": "rename",
        }

        return c.post("{{$.Name}}", "", qs, payload)
}

func (c *NitroClient) Count{{$.Name|name}} () (int, error) {
        var results count_{{$.Name}}_result
        
        qs := map[string]string {
                "count": "yes",
        }

	if err := c.get("{{$.Name}}", "", qs, &results); err != nil {
                return -1, err
        } else {
                return results.Results[0].Count, err
        }
}

func (c *NitroClient) Exists{{$.Name|name}} (key {{if $.Schema.Key.Fields}}{{$.Name|name}}Key{{else}}string{{end}}) (bool, error) {
        var results count_{{$.Name}}_result
        
        id, qs := {{$.Name}}_key_to_id_args(key)

        qs["count"] = "yes"

	if err := c.get("{{$.Name}}", id, qs, &results); err != nil {
                // TODO : detect 404
                // return false, err
                return false, nil
        } else {
                return results.Results[0].Count == 1, nil
        }
}

func (c *NitroClient) List{{$.Name|name}} () ([]{{$.Name|name}}, error) {
        results := get_{{$.Name}}_result{}
        
	if err := c.get("{{$.Name}}", "", nil, &results); err != nil {
                return nil, err
        } else {
                return results.Results, err
        }
}

func (c *NitroClient) Get{{$.Name|name}} (key {{if $.Schema.Key.Fields}}{{$.Name|name}}Key{{else}}string{{end}}) (*{{$.Name|name}}, error) {
        var results get_{{$.Name}}_result
        
        id, qs := {{$.Name}}_key_to_id_args(key)

	if err := c.get("{{$.Name}}", id, qs, &results); err != nil {
                return nil, err
        } else {
                if len(results.Results) > 1 {
                        return nil, fmt.Errorf("More than one {{$.Name}} element found")
                } else if len(results.Results) < 1 {
                        return nil, fmt.Errorf("{{$.Name}} element not found")
                }

                return &results.Results[0], nil
        }
}

func (c *NitroClient) Delete{{$.Name|name}} (key {{if $.Schema.Key.Fields}}{{$.Name|name}}Key{{else}}string{{end}}) error {
        id, qs := {{$.Name}}_key_to_id_args(key)

        return c.delete("{{$.Name}}", id, qs)
}

{{if $.Schema.Update -}}
func (c *NitroClient) Unset{{$.Name|name}} (unset {{$.Name|name}}Unset) error {
        payload := unset_{{$.Name}}_payload {
                unset,
        }

        qs := map[string]string {
                "action": "unset",
        }

        return c.put("{{$.Name}}", "", qs, payload)
}

func (c *NitroClient) Update{{$.Name|name}} (resource {{$.Name|name}}) error {
        payload := update_{{$.Name}}_payload {
                update_{{$.Name}} {
                        resource.{{$.Schema.Key.Name|title}},
                        {{range $field := $.Schema.Key.Fields -}}
                        resource.{{$field|title}},
                        {{end -}}
                        {{range $field := $.Schema.Update -}}
                        {{if not (is_in $field $.Schema.Key.Fields) -}}
                        resource.{{$field|title}},
                        {{end -}}
                        {{end -}}
                },
        }

        return c.put("{{$.Name}}", "", nil, payload)
}

{{end -}}
{{if $.Schema.State -}}
func (c *NitroClient) Enable{{$.Name|name}} (key {{if $.Schema.Key.Fields}}{{$.Name|name}}Key{{else}}string{{end}}) error {
        payload := state_{{$.Name}}_payload {
                state_{{$.Name}} {
                        key,
                },
        }

        qs := map[string]string {
                "action": "enable",
        }

        return c.post("{{$.Name}}", "", qs, payload)
}

func (c *NitroClient) Disable{{$.Name|name}} (key {{if $.Schema.Key.Fields}}{{$.Name|name}}Key{{else}}string{{end}}) error {
        payload := state_{{$.Name}}_payload {
                state_{{$.Name}} {
                        key,
                },
        }

        qs := map[string]string {
                "action": "disable",
        }

        return c.post("{{$.Name}}", "", qs, payload)
}
{{end -}}
